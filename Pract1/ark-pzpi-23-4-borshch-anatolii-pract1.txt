Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії









Практична робота № 1
з дисципліни «Скриптові мови програмування»








Виконав						       Перевірив
ст. гр. ПЗПІ-23-4                                                 ст. вик. Сокорчук Ігор Петрович
Борщ Анатолій Сергійович					



Харків 2025
1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
21.10.2025
1.0
Зробив заповнив основні розділи











2 ЗАВДАННЯ
     Мета заняття:
     Ознайомити студентів з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для різних мов програмування, а також навчити аналізувати та рефакторити код для покращення його якості.
     Завдання:
     Студент повинен обрати мову програмування, дослідити основні рекомендації для написання якісного коду у цій мові, продемонструвати ці рекомендації на прикладах коду, обґрунтувати кожну рекомендацію і надати детальні пояснення. Для кожного прикладу мають бути наведені фрагменти коду.



3 ОПИС ВИКОНАНОЇ РОБОТИ
Тема: Правила оформлення програмного коду C# за стандартами MSDN

     1. Структура коду
     Кожен файл у C# повинен мати чітку структуру, яка відповідає стандартам Microsoft (MSDN) і забезпечує логічну послідовність елементів. У верхній частині файлу можна розмістити короткий опис призначення файлу, автора, дату створення, версію або іншу службову інформацію. Всі підключення просторів розміщуються на початку файлу.
Важливо групувати їх логічно:
• спочатку стандартні простори імен .NET
• потім власні простори імен проєкту,
• а після цього — сторонні бібліотеки.
Далі оголошується простір імен, який відповідає структурі папок у проєкті. Це дозволяє підтримувати логічну ієрархію та уникати конфліктів назв. У межах простору імен розміщуються всі типи: класи, інтерфейси, структури, перерахування.
У кожному файлі повинен бути лише один публічний клас або інтерфейс, ім’я якого повністю збігається з іменем файлу. 
Вкладені класи використовуються лише тоді, коли клас логічно належить іншому і не має сенсу поза ним.
Поля використовуються для зберігання даних усередині класу. Спочатку — константи (const), потім статичні (static), далі звичайні екземплярні поля.
Властивості надають доступ до полів через публічні властивості. Якщо є властивості лише для читання (get), вони розміщуються перед властивостями для запису (set).
Конструктори всі конструктори класу мають бути згруповані разом, спочатку стандартний, потім із параметрами.
Методи розміщуються за логічним призначенням або за рівнем доступу: публічні вище, приватні нижче. Події групуються окремо, після методів.
Використання директив #region і #endregion дозволяє логічно згрупувати великі ділянки коду.

     2. Форматування коду
     Кожен рівень вкладеності коду повинен мати відступ у чотири пробіли. Використання табуляції замість пробілів не рекомендується, адже у різних середовищах розробки відображення табуляцій може відрізнятися. Відступи застосовуються до всіх елементів, розташованих у межах фігурних дужок: методів, умовних конструкцій, циклі.
Щодо дужок, рекомендовано використовувати стиль Allman, коли відкриваюча фігурна дужка { розміщується на новому рядку під тим елементом, до якого вона належить. Такий стиль забезпечує кращу читабельність і полегшує сприйняття структури коду. Закриваюча дужка } завжди має стояти під першим символом оголошення відповідного блоку. Це правило поширюється на класи, методи, оператори if, for, while, switch.
Використання пробілів також має свої правила. Перед і після операторів присвоєння та порівняння, а саме “=”, “==”, “+”, “-“,  “&&”, “||”, “<”, “>”. Завжди повинен стояти один пробіл. Після ключових слів if, for, while, catch, foreach, switch також ставиться один пробіл перед відкриваючою круглою дужкою. Натомість перед крапкою з комою “;,” комою “,” або закриваючою дужкою “)” пробіли не ставляться, але після коми пробіл має бути обов’язково.
Порожні рядки використовуються для логічного розділення частин коду, а не для декоративних цілей. Один порожній рядок додається між методами, між групами полів і властивостей, а також між розділами директив using. Два або більше підряд порожніх рядків вважаються надмірними й не допускаються.
Загальне правило полягає в тому, що кожен логічно завершений блок коду відокремлюється одним порожнім рядком для покращення сприйняття структури класу.
Довжина кожного рядка не повинна перевищувати 65 символів. Якщо вираз є довгим, його потрібно переносити. У випадку викликів методів або ланцюжків LINQ-запитів перенос робиться після крапки, при цьому наступний рядок вирівнюється за відкриваючою дужкою або з невеликим додатковим відступом.
Атрибути, які описують класи, методи або властивості, розміщуються безпосередньо перед відповідним елементом. Якщо атрибутів декілька, кожен записується на окремому рядку.

     3. Іменування (Naming Conventions)
     Імена повинні бути зрозумілими, короткими та інформативними.
Назви мають бути іменниками.
Уникайте скорочень, які не є загальноприйнятими або легко збивають з пантелику. Наприклад, Html, Id, Xml є допустимими, а UsrMng або Tmp — ні.
Не додавайте тип до імені змінної чи методу. Наприклад, stringName або intCounter небажано.
Для классів, структур, типу перечислення використовувати PascalCase. Не додавайте суфікси, що дублюють тип елемента. Для перерахувань також використовуйте PascalCase, а елементи enum - PascalCase без префіксів. Назви елементів мають чітко описувати значення у типі перечислення.
Імена інтерфейсів починаються з літери I, далі PascalCase. Ім’я має описувати поведінку або контракт, а не конкретну сутність.
Для методів потрібно використовувати PascalCase. Імена методів повинні бути дієсловами або дієслівними фразами, що описують дію. Уникайте префіксів типу Do, Handle, Process, якщо вони не додають сенсу. Асинхронні методи закінчуються на Async. Для обробників подій використовуйте шаблон On<EventName> (OnUserAdded).
Для властивостей використовувати PascalCase. Імена властивостей повинні бути іменниками або прикметниками, що описують значення або стан. Не додавайте префікси Get або Set - властивість сама відображає доступ.
Поля використовують Camel Case. Приватні поля мають підкреслення спочатку.
Локальні змінні та параметри використовують Camel Case. Імена повинні відображати значення, яке зберігає змінна.
Параметри методів також пишуться у Camel Case.

     4. Коментарі
     Коментарі в коді служать для пояснення логіки, рішень і призначення окремих елементів коду. Вони допомагають розробникам швидше зрозуміти, що робить код, чому він реалізований саме так, і які обмеження чи нюанси потрібно враховувати.
Однорядкові коментарі використовуються для коротких пояснень, поміток або службових тегів (TODO, NOTE). Коментар розташовується над рядком або блоком коду, рідше після рядка, якщо пояснення дуже коротке.
Багаторядкові коментарі використовуються для пояснення довгих блоків коду або складної логіки. Підходять для тимчасових заміток, але не повинні перевантажувати метод великим текстом.
XML-коментарі Використовуються для публічних API, класів, методів та властивостей. Дозволяють формувати документацію, що автоматично відображається у IDE або зовнішніх системах документування.
До усіх коментарів також завтосовуються загальні правила:
• Не дублювати очевидний код
• Коментарі використовуються для пояснення логіки або рішень
• Не залишати закоментований код у фінальній версії
• Актуальність коментарів
5. Документування коду
     У процесі розробки на C# важливо дотримуватися стандартів документування, рекомендованих MSDN. Основним інструментом для цього є XML-коментарі. Вони дозволяють створювати формалізовану документацію для класів, методів, властивостей і модулів, забезпечуючи розробникам зручні підказки IntelliSense та можливість автоматичної генерації довідкових матеріалів.
     XML-коментарі записуються за допомогою трьох слешів /// та містять структуровані теги: <summary> для короткого опису призначення елемента, <param> для пояснення параметрів, <returns> для опису значення, яке повертає метод, а також <remarks>, <example> і <exception>, що дають змогу фіксувати додаткові відомості, приклади використання та можливі виняткові ситуації. Такий формат забезпечує чіткість і стандартизовану форму подання інформації, що спрощує командну роботу та подальше супроводження коду.
     Особливо важливими є три типи документації: опис функціональності (summary), опис параметрів (param) і опис повернених значень (returns). Вони формують основу документації та дозволяють іншим розробникам швидко зрозуміти логіку роботи методу без необхідності читати реалізацію. Наявність прикладів використання також підвищує практичну цінність документації, а фіксація винятків допомагає правильно обробляти помилки.
     6. Інструменти для підтримки чистоти коду
     Для підтримки чистоти та якості C#-коду використовуються інструменти, що допомагають контролювати стиль, структуру та відповідність стандартам MSDN. 
     Одним із ключових є ReSharper, який виконує глибокий аналіз коду, знаходить помилки, дублікати, проблеми зі стилем та пропонує автоматичні варіанти виправлень. Він також надає інструменти рефакторингу й оптимізації, що значно спрощує підтримку проекту.
     Для контролю форматування та стилю використовується StyleCop та EditorConfig. StyleCop забезпечує перевірку коду на відповідність стандартам Microsoft (іменування, розташування елементів, структура файлів), а EditorConfig дозволяє централізовано задавати правила форматування для всього рішення, забезпечуючи єдиний стиль у команді.
     У роботі з API важливу роль відіграє Swagger (OpenAPI), що автоматично генерує документацію для REST-сервісів, відображає структуру endpoint-ів та моделі даних. Це допомагає підтримувати чистоту коду на рівні API та забезпечує узгодженість між бекендом і клієнтськими застосунками.
     Доповнюють екосистему такі інструменти, як SonarQube та вбудовані Roslyn Analyzers, які виконують статичний аналіз, виявляють потенційні помилки, порушення стилю та проблеми безпеки. Усі ці рішення разом забезпечують високий рівень якості, читабельності та підтримуваності програмного коду.



4 ВИСНОВКИ
     У результаті розгляду правил оформлення програмного коду за стандартами MSDN було проаналізовано основні аспекти побудови якісного та зрозумілого коду: структуру, форматування, іменування, коментування та документування. Дотримання цих принципів забезпечує єдність стилю в команді розробників, підвищує читабельність, полегшує супровід і тестування програмного забезпечення. Правильне оформлення коду не лише демонструє професійність розробника, а й сприяє створенню надійних, масштабованих і зрозумілих програмних систем.


5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Microsoft C# Coding Conventions (MSDN / Docs) URL: https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions


ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/2jsISAuUFnI
Хронологічний опис відеозапису:
00:00 – Введення
00:45 – Структура коду
02:48 – Форматування коду
05:02 – Іменування
07:28 – Коментарі
08:53 – Документування коду
10:19 – Інструменти підтримки чистоти коду


ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Вітальний слайд з темою


Рисунок Б.2 – Перший слайд


Рисунок Б.3 – Другий слайд


Рисунок Б.4 – Четвертий слайд


Рисунок Б.5 – П’ятий слайд


Рисунок Б.6 – Шостий слайд


Рисунок Б.7 – Сьомий слайд


Рисунок Б.8 – Восьмий слайд


Рисунок Б.9 – Дев'ятий слайд


Рисунок Б.10 – Десятий слайд


Рисунок Б.11 – Одинадцятий слайд


Рисунок Б.12 – Дванадцятий слайд


Рисунок Б.13 – Тринадцятий слайд


Рисунок Б.14 – Чотирнадцятий слайд


Рисунок Б.15 – П'ятнадцятий слайд


Рисунок Б.16 – Шістнадцятий слайд


Рисунок Б.17 – Кінцевий слайд


ДОДАТОК В
В.1 Поганий приклад структуру коду
1 using MyApp.Services; // Сторонні простори йдуть першими
2 
3 public class UserManager
4 {
5 public void Save() { } // Метод перед полями і конструкторами
6 
7 private string _name; // Поле після методу
8 
9 public UserManager() {} // Конструктор в середині класу
10 
11 private const int Max = 10; // Константа після методу
12 }

В.2 Гарний приклад структуру коду
1 using System; // Спочатку стандартні простори
2 using MyApp.Services; // Потім власні/сторонні простори
3 
4 namespace MyApp.Core
5 {
6 public class UserManager
7 {
8 private const int Max = 10; // Константи першими
9 
10 private string _name; // Поля після констант
11 
12 public UserManager() {} // Конструктори після полів
13 
14 public void Save() { } // Методи після полів і конструкторів
15 }
16 }

В.3 Поганий приклад форматування
1 using System; 
2 using MyApp.Services;
3 
4 namespace MyApp.Core{
5 public class UserManager{
6 private string _name;
7 private const int Max=10;
8 public string Id{get;set;}
9 public UserManager(){}
10 public void Save(){Console.WriteLine(_name);}
11 if(_name==""){Console.WriteLine("Empty");}
12 }
13 }

В.4 Гарний приклад форматування

1 using System;
2 using MyApp.Services;
3 
4 namespace MyApp.Core 
5 { // Allman стиль відкриваючої дужки
6 public class UserManager // один публічний клас = назві файлу
7 { // Allman стиль
9 private const int Max = 10; // константи першими, пробіли навколо =
10 
12     private string _name; // приватне поле, після констант
13 
15 public string Id { get; set; } // властивості після полів
16 
18 public UserManager() { } // конструктори після полів
19 
21 public void Save() // метод після конструкторів
22 { // Allman стиль
23 Console.WriteLine(_name); // відступи 4 пробіли
24 
25 if (_name == "") // пробіли навколо операторів та після if
26 { // Allman стиль для if
27 Console.WriteLine("Empty"); // відступи
28 }
29 }
30 }
31 }

В.5 Поганий приклад іменування
1 public class usrMng // скорочення, не PascalCase
2 {
3 private string name1; // цифра в імені, неінформативне
4 public string strId; // тип у назві
5 
6 public void do_it() { } // метод із нижнім підкресленням, не PascalCase
7 public void ProcessData() { } // зайвий префікс Process
8 
9 public void handleEvent() { } // нижній регістр на початку
10 }

В.6 Гарний приклад іменування
1 public class UserManager // PascalCase, зрозуміла назва
2 {
3 private string _name; // приватне поле, camelCase з підкресленням
4 public string Id { get; set; } // властивість PascalCase
5 
6 public void Save() { } // метод PascalCase, дієслово
7 public void LoadDataAsync() { } // асинхронний метод Async
8 public void OnUserAdded() { } // обробник події за шаблоном
9 }

В.7 Поганий приклад коментарів
1 public class UserManager
2 {
3 private string _name;
4 
5 public void Save()
6 {
7 // змінна name використовується тут
8 Console.WriteLine(_name); // вивід на консоль
9 // TODO: дописати логіку
10 /* цей код робить щось важливе */ Console.WriteLine("Test");
11 }
12 }
В.8 Гарний приклад коментарів
1 public class UserManager
2 {
3 private string _name; 
4 
5 /// <summary>
6 /// Зберігає інформацію користувача та виводить на консоль.
7 /// </summary>
8 public void Save()
9 {
10 Console.WriteLine(_name); // пояснює, що саме виводиться
11 }
12 }

В.9 Поганий приклад документування
1 public class Calculator
2 {
3 public int Add(int a, int b)
4 {
5 return a + b; // додавання двох чисел
6 }
7 }

В.10 Гарний приклад документування
1 public class Calculator
2 {
3 /// <summary>
4 /// Повертає суму двох цілих чисел.
5 /// </summary>
6 /// <param name="a">Перше число</param>
7 /// <param name="b">Друге число</param>
8 /// <returns>Сума чисел a та b</returns>
9 /// <example>
10 /// var calc = new Calculator();
11 /// int result = calc.Add(2, 3); // result = 5
12 /// </example>
13 public int Add(int a, int b)
14 {
15 return a + b;
16 }
17 }

2







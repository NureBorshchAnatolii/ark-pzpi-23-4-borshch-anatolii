Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії









Практична робота № 2
з дисципліни «Скриптові мови програмування»








Виконав						       Перевірив
ст. гр. ПЗПІ-23-4                                                 ст. вик. Сокорчук Ігор Петрович
Борщ Анатолій Сергійович					



Харків 2025
1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
07.12.2025
1.0
Зробив заповнив основні розділи











2 ЗАВДАННЯ
     2.1 Мета заняття:
   Навчити студентів основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проєктів. Студенти повинні навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.
   2.2 Завдання:
1. Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
2. Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
3. Кожен метод рефакторингу повинен супроводжуватись:
1. Описом проблеми, яку вирішує даний метод.
2. Кодом до і після застосування методу рефакторингу.
3. Поясненням переваг використаного методу.



3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
     У процесі розробки програмного забезпечення якість вихідного коду відіграє критично важливу роль у підтримуваності, зрозумілості та розширюваності системи. Навіть функціонально коректний код із часом може ставати надмірно складним, дубльованим або заплутаним, що ускладнює його подальшу модифікацію. Для запобігання цьому використовують техніки рефакторингу - систематичного покращення внутрішньої структури коду без зміни його зовнішньої поведінки.
     У межах даної роботи буде розглянуто три поширені та практично значущі методи рефакторингу:
1. Replace Temp with Query - метод, що дозволяє позбутися проміжних змінних, винісши обчислення у окремі методи. Це сприяє покращенню читабельності, усуненню дублювання та підвищенню повторного використання логіки.
2. Replace Conditional with Polymorphism - техніка, яка використовується для усунення розгалужених умовних конструкцій, таких як if-else чи switch, шляхом перенесення різних варіантів поведінки у підкласи. Такий підхід підвищує відповідність принципам ООП, зменшує складність коду та полегшує його розширення.
3. Simplify Conditional Expression - метод, який дозволяє зменшити складність умов, уникнути вкладених конструкцій та зробити логіку більш зрозумілою. Часто включає використання ранніх виходів або виділення логічних перевірок у допоміжні методи.
     Ці методи буде детально проаналізовано та застосовано на прикладі міні-застосунку MessageSenderApp, що реалізує створення та відправку повідомлень різними каналами. У роботі буде проведено аналіз вихідного коду, виявлено проблемні ділянки та виконано рефакторинг з демонстрацією покращеної структури програми.
     
     3.2 Перший приклад
     Початковий код
     Нижче наведений фрагмент класу MessageBuilder, який відповідає за формування тексту повідомлення перед його відправкою, див додаток B.1.
     У наведеному коді присутні кілька ознак, що вказують на необхідність рефакторингу, а самме те, що змінні header, footer, dateInfo, fullMessage представляють собою лише проміжні значення, які не несуть самостійної логічної цінності. Якщо доведеться змінити структуру заголовка або формат дати, такі зміни потрібно буде робити всередині методу. Це робить метод громіздким і менш гнучким. Порушення принципу єдиної відповідальності формує привітання, визначає дату, формує футер, збирає усе в один текст. У методі змішано логіку збору різних частин повідомлення, тому читачеві складніше осягнути загальну структуру та призначення операцій.
     Для вирішення цих проблем застосовується метод Replace Temp with Query
     Тимчасові змінні замінюються викликами окремих методів, як запитів, які повертають потрібний результат. Це:
• спрощує основний метод, роблячи його компактним і логічним;
• покращує читабельність, оскільки кожен допоміжний метод має чітку назву й відповідальність;
• усуває дублювання, тому що логіку формування кожної частини можна повторно використовувати.
     Цей метод підхоть тому, що:
• Кожна частина повідомлення логічно є окремою одиницею поведінки.
• Тимчасові змінні не потрібні для оптимізації - вони лише тримають значення між операціями.
• Метод стає більш гнучким: можна легко змінити формат дати чи стиль привітання, не переписуючи весь BuildMessage.
• Код стає ближчим до декларативного стилю.
Див. додаток В.2.
      
     3.3 Другий приклад
     Нижче буде наведено метод відправки повідомлень трьох видів: Email, SMS, Push-сповіщення
      Метод відправки містить довгий switch, який постійно розростається та ускладнює підтримку, див. додаток В.3.
     Одразу видно порушення Open-Closed Principle, коли додається новий тип повідомлення, потрібно змінювати switch тобто модифікується наявний робочий код. Метод Send() стає дедалі довшим. Увесь код у методі переплетений, тому його складно розбивати на незалежні юніт-тести.
     Через це найкращім вибором буде використовувати Replace Conditional with Polymorphism метод, тому що:
• замінюємо великий switch на окремі класи
• кожен тип повідомлення сам знає, як відправлятись
• немає потреби змінювати центральний клас при додаванні нового типу
• логіка стає модульною, тестованою й розширюваною
  Після рефакторингу:
• центральний клас чистий і короткий
• додати новий тип можна без зміни існуючого коду
• логіка розділена по класах легше підтримувати
• кожен клас легко тестувати
• відповідність SOLID, OCP, SRP
Див. додаток В.4.
   3.4 Третій приклад
   У системі відправки повідомлень є логіка перевірки, чи можна взагалі надсилати повідомлення користувачу. Код містить довгу й заплутану перевірку з вкладеними умовами, див. додаток В.5.
   Проблеми коду:
1. Глибока вкладеність
2. Порушення принципу “fail fast”
3. Ускладнення підтримки
4. Складність тестування
   Найкращім вибором для вирішення цих проблем буде використання Simplify Conditional Expression, тому що:
• дозволяє позбутися вкладених if-ів
• робить перевірки коротшими, прозорими
• переводить логіку на ранні виходи
• підвищує читабельність і підтримуваність
• спрощує тестування
Див. додаток В.6.
   Переваги після рефакторингу:
1. читабельність значно підвищилась
2. вкладеність зникла повністю
3. логіка стала очевидною
4. додати нову умову тепер легко
5. чітко видно, яка перевірка не пройшла
6. код відповідає стилю clean code


4 ВИСНОВКИ
     У ході роботи було проаналізовано вихідний код міні-застосунку MessageSenderApp, який реалізує створення та відправку повідомлень різними каналами. Було виявлено низку проблемних ділянок, зокрема надмірне використання тимчасових змінних при формуванні повідомлення, довгі умовні конструкції при відправці повідомлень та складні вкладені перевірки прав користувача. Ці недоліки ускладнювали читабельність, тестування та розширення системи, а також порушували принципи чистого коду та OOP.
     Для покращення структури коду було застосовано методи рефакторингу: Replace Temp with Query, Replace Conditional with Polymorphism та Simplify Conditional Expression. Завдяки цьому код став більш зрозумілим і модульним, кожна частина логіки була винесена в окремі методи або класи, а складні умови спрощено. Результатом стало підвищення читабельності, підтримуваності та розширюваності системи, при цьому функціональна поведінка програми залишилась без змін. Використання цих методів демонструє ефективний підхід до підвищення якості програмного забезпечення в процесі його розвитку та підтримки.


5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Martin Fowler — “Refactoring: Improving the Design of Existing Code” (2nd Edition). URL: https://dl.ebooksworld.ir/motoman/Refactoring.Improving.the.Design.of.Existing.Code.2nd.edition.www.EBooksWorld.ir.pdf
2. Official Microsoft C# Documentation – Best practices and code quality guidelines. URL: https://learn.microsoft.com/en-us/dotnet/csharp/


ДОДАТОК А
Відеозапис
https://youtu.be/TRuHhXBU3y0
Хронологічний опис відеозапису:
00:00 – Вступ.
00:52 – Загальна теорія.
02:18 – Перший приклад.
04:10 – Другий приклад.
05:59 – Третій приклад.
07:16 – Висновки.



ДОДАТОК Б
Слайди презентації


Рисунок Б.1 – Титульний слайд.


Рисунок Б.2 – Перший слайд.

Рисунок Б.3 – Другий слайд.


Рисунок Б.4 – Третій слайд.



Рисунок Б.5 – Четвертий слайд.


Рисунок Б.6 – П’ятий слайд.



Рисунок Б.7 – Шостий слайд.


Рисунок Б.8 – Сьомий слайд.



Рисунок Б.9 – Восьмий слайд.


Рисунок Б.10 – Слайд з висновками.



Рисунок Б.11 – Кінцевий слайд.


ДОДАТОК В
Програмний код

В.1 Перший приклад, до рефакторингу
public class MessageBuilder
{
    public string BuildMessage(User user, string content)
    {
        string header = "Hello " + user.Name;
        string footer = "Regards, Message System";

        string dateInfo = DateTime.Now.ToString("dd.MM.yyyy HH:mm");
        string fullMessage = header + "\n" + content + "\n" + dateInfo + "\n" + footer;

        return fullMessage;
    }
}

В.2 Перший приклад, після рефакторингу
      public class MessageBuilder
      {
          public string BuildMessage(User user, string content)
          {
              return $"{BuildHeader(user)}\n{content}\n{BuildDateInfo()}\n{BuildFooter()}";
          }
      
          private string BuildHeader(User user)
          {
              return $"Hello {user.Name}";
          }
      
          private string BuildFooter()
          {
              return "Regards, Message System";
          }
      
          private string BuildDateInfo()
          {
              return DateTime.Now.ToString("dd.MM.yyyy HH:mm");
          }
      }

В.3 Другий приклад, до рефакторингу
      public class MessageSender
      {
          public void Send(Message message)
          {
              switch (message.Type)
              {
                  case MessageType.Email:
                      Console.WriteLine($"Sending EMAIL to {message.Recipient}: {message.Text}");
                      break;
      
                  case MessageType.Sms:
                      Console.WriteLine($"Sending SMS to {message.Recipient}: {message.Text}");
                      break;
      
                  case MessageType.Push:
                      Console.WriteLine($"Sending PUSH to {message.Recipient}: {message.Text}");
                      break;
      
                  default:
                      throw new Exception("Unsupported message type");
              }
          }
      }

В.4 Другий приклад, після рефакторингу

      public abstract class MessageSenderBase
      {
          public abstract void Send(Message message);
      }
      
      public class EmailSender : MessageSenderBase
      {
          public override void Send(Message message)
          {
              Console.WriteLine($"Sending EMAIL to {message.Recipient}: {message.Text}");
          }
      }
      
      public class SmsSender : MessageSenderBase
      {
          public override void Send(Message message)
          {
              Console.WriteLine($"Sending SMS to {message.Recipient}: {message.Text}");
          }
      }
      
      public class PushSender : MessageSenderBase
      {
          public override void Send(Message message)
          {
              Console.WriteLine($"Sending PUSH to {message.Recipient}: {message.Text}");
          }
      }
      public class MessageSenderFactory
      {
          public static MessageSenderBase Create(MessageType type)
          {
              return type switch
              {
                  MessageType.Email => new EmailSender(),
                  MessageType.Sms => new SmsSender(),
                  MessageType.Push => new PushSender(),
                  _ => throw new Exception("Unsupported message type")
              };
          }
      }
      
      public class MessageService
      {
          public void Send(Message message)
          {
              var sender = MessageSenderFactory.Create(message.Type);
              sender.Send(message);
          }
      }

В.5 Третій приклад, до рефакторингу

public class MessagePermissionService
{
    public bool CanSendMessage(User user, Message message)
    {
        if (user != null)
        {
            if (!user.IsBlocked)
            {
                if (user.AccountStatus == AccountStatus.Active)
                {
                    if (!string.IsNullOrWhiteSpace(message.Text))
                    {
                        if (!user.HasDailyLimitReached())
                        {
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    }
}

В.6 Третій приклад, після рефакторингу

public class MessagePermissionService
{
    public bool CanSendMessage(User user, Message message)
    {
        if (user == null)
            return false;

        if (user.IsBlocked)
            return false;

        if (user.AccountStatus != AccountStatus.Active)
            return false;

        if (string.IsNullOrWhiteSpace(message.Text))
            return false;

        if (user.HasDailyLimitReached())
            return false;

        return true;
    }
}



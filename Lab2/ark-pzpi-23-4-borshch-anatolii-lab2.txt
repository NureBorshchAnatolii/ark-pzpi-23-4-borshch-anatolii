Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії






Звіт
з лабораторної роботи № 2
з дисципліни «Аналіз та рефакторинг коду»
на тему «Розробка бази даних для серверної частини системи та прикладного програмного інтерфейсу (API)»







Виконав								Перевірив
ст. гр. ПЗПІ-23-4	ст. вик. Сокорчук Ігор 
Борщ Анатолій Сергійович					Петрович



Харків 2025
1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
16.11.2025
1.0
Зробив заповнив основні розділи











2 ЗАВДАННЯ
     2.1 Мета роботи:
     Ознайомитися з процесом розробки серверної частини програмної системи, включаючи проектування бази даних (БД), розробку API для взаємодії з клієнтами, та перевірку (тестування) їхньої взаємодії. Оволодіти методами проектування діаграм UML та ER, розробки БД, програмної реалізації API, а також роботи з репозиторіями Git та створення технічної документації.
   2.2 Завдання:
1. Розробити будову програмної системи:
o Сформулювати архітектурні рішення для серверної частини системи, клієнтських взаємодій та БД.
o Описати моделі, що використовуються в системі, та зв'язки між ними.
2. Створити UML діаграму прецедентів для серверної частини системи:
o Використовуйте UML для опису основних прецедентів використання серверної частини. Діаграма повинна включати дії користувачів та взаємодії між ними та системою.
3. Створити ER діаграму даних:
o Визначте сутності, атрибути та зв’язки між ними у вашій БД. Використовуйте ER діаграму для наочного відображення структури даних.
4. Розробити базу даних (БД) програмної системи:
o На основі ER діаграми спроєктуйте таблиці БД.
o Описати схему нормалізації даних (1NF, 2NF, 3NF).
5. Створити діаграму структури БД:
o Діаграма повинна показувати всі таблиці, зв’язки між ними, ключові поля та обмеження.
6. Розробити функції роботи з БД (ORM або CoRM тощо):
o Реалізуйте методи доступу до БД, використовуючи ORM (Object-Relational Mapping) або CoRM (Custom ORM).
o Функції повинні підтримувати CRUD-операції (Create, Read, Update, Delete) для основних сутностей.
7. Розробити API для взаємодії серверної частини з клієнтами:
o Визначте, який тип API буде використовуватися: REST, GraphQL або gRPC.
o Описати ендпоінти, які будуть реалізовані в API, їхні методи (GET, POST, PUT, DELETE) та параметри.
8. Створити специфікацію розробленого API:
o Специфікація повинна містити: 
• Опис кожного ендпоінту.
• Формат запитів та відповідей.
• Приклади використання API.
9. Створити програмну реалізацію API та функцій роботи з БД:
o Реалізуйте серверну частину системи із доступом до БД та можливістю обробки запитів через API.
o Перевірте коректність роботи API та його взаємодію з БД.
10. Перевірити роботу створеного програмного коду серверної частини системи:
o Проведіть тестування розроблених функцій, зокрема перевірте взаємодію API з БД.


3 ОПИС ВИКОНАНОЇ РОБОТИ
       1. Розробка та будова програмної системи.
       Серверна частина системи CareLink буде розроблена з використанням .NET Web API та мови програмування C. Архітектура бекенду ґрунтуватиметься на принципах Чистої архітектури, яка передбачає чітке розділення шарів на доменний рівень, рівень застосунку, інфраструктуру та API. У серверній частині будуть використовуватись репозиторії для абстракції доступу до даних, а також сервіси як агрегуючий шар, який відповідає за бізнес-логіку, валідацію моделей та координацію роботи між репозиторіями. Взаємодія між клієнтом і сервером здійснюватиметься через RESTful API із використанням JSON.
       Окремим компонентом системи буде модуль реального текстового чату, який реалізується за допомогою ASP.NET SignalR, що працює поверх WebSockets.
       У серверній частині будуть використовуватись репозиторії для абстракції доступу до даних, а також сервіси як агрегуючий шар, який відповідає за бізнес-логіку, валідацію моделей та координацію роботи між репозиторіями. 
       Для забезпечення надійності та тестованості застосунку передбачено використання фреймворку xUnit для модульного тестування ключових компонентів. Тести охоплюватимуть доменні сервіси, бізнес-правила, а також роботу репозиторіїв через mock-реалізації.
       На додаток буде застосований AutoMapper для мапінгу DTO-моделей, FluentValidation для декларативної перевірки даних, а також Dependency Injection.
       
       2. UML діаграма прецедентів для серверної частини системи.
       Створена UML-діаграма прецедентів відображає основні взаємодії між зовнішніми акторами системи CareLink та серверною частиною.
       Літній користувач - основний учасник системи, для якого створюється більшість функцій CareLink. Він має можливість реєстрації та входу в систему, а також змінювати свій пароль у разі потреби. Користувач може переглядати встановлені йому нагадування, виконувати когнітивні вправи та переглядати власні IoT-показники, які надходять з підключених пристроїв (пульс, активність). Також передбачена можливість надсилання сигналу тривоги, коли користувач потребує термінової допомоги. Він може переглядати надіслані йому повідомлення та взаємодіяти з ними. У разі відміни прийому ліків користувач може повідомляти родичів або медичного працівника, що допомагає краще контролювати лікування. Літній користувач отримує push-сповіщення про нагадування та важливі події в системі.
       Родич - це користувач, який має доступ до стану літнього родича та може взаємодіяти з його профілем. Він може переглядати push-сповіщення про стан користувача, його IoT-дані та отримані ним тривожні сигнали. Також родич може створювати нагадування для літнього користувача: наприклад, щодо прийому ліків або медичних процедур. Він має можливість переглядати отримані повідомлення і відправляти власні, підтримуючи двосторонню комунікацію. Родич також бачить виконання когнітивних вправ користувача й отримує повідомлення у випадку позаштатних ситуацій, наприклад падіння або різкого підвищення пульсу. Взаємодія родича із системою спрямована на забезпечення контролю та підтримки літньої людини.
       Медичний працівник має доступ до ширшого функціоналу для моніторингу стану пацієнтів. Він може переглядати базові IoT-показники, що надходять з пристроїв користувачів, і отримувати критичні сповіщення. Крім того, він може створювати нагадування для пацієнтів, наприклад про процедури, огляди або прийом препаратів. Медичний працівник може надсилати повідомлення та переглядати історію сповіщень, забезпечуючи медичну підтримку користувачів.
       Адміністратор системи відповідає за технічне управління та підтримку роботи платформи. Його можливості включають перегляд логів системи для моніторингу помилок, підозрілої активності або загальної стабільності роботи. Він має можливість видаляти користувачів, створювати нові ролі та управляти їхніми правами. Адміністратор контролює структуру системи, забезпечує безпеку даних і виступає останнім рівнем підтримки. Усі дії адміністратора спрямовані на стабільну та безперебійну роботу сервісу.
       Система сповіщень - зовнішній актор, який забезпечує доставку push-повідомлень до мобільних або веб-клієнтів. Вона приймає запити від серверної частини CareLink на надсилання нагадувань, критичних сповіщень або інформаційних повідомлень. 
       Платіжний сервіс відповідає за обробку оплати підписок користувачів. Він приймає запити на створення, підтвердження або відміну платежів, а також надсилає відповідь про успішність транзакції. У системі він використовується родичами або літніми користувачами для оформлення або продовження підписки. 
       IoT-пристрої є джерелом фізичних даних про стан користувача. Вони надсилають на сервер інформацію про пульс, активність, температуру та сигнали падіння. Ці пристрої діють як зовнішній актор і автоматично взаємодіють із системою через API. Передані ними дані використовуються для аналітики, створення сповіщень та сповіщення родичів або медичних працівників про надзвичайні ситуації.
       
       3. ER діаграма даних.
       ER-діаграма відображає структуровану модель даних системи CareLink, охоплюючи всі сутності, їх атрибути та зв’язки між ними. Вона включає ключові таблиці, такі як Users, Roles, Relatives, IoTDevices, IoTReadings, Notifications, Messages, Subscriptions, CognitiveExercises і Reminders. У діаграму також включено допоміжні словники, такі як NotificationTypes, SubscriptionPlanTypes, SubscriptionStatuses, IoTDeviceTypes, CognitiveExerciseTypes і RelativeTypes.
       
       4. База даних (БД) програмної системи.
       
       На основі побудованої ER-діаграми була розроблена реляційна база даних, у якій кожна сутність представлена окремою таблицею з чітко визначеними первинними та зовнішніми ключами. Таблиці містять атомарні поля, структуровані відповідно до функціональних вимог системи. Завдяки розділенню основних бізнес-сутностей і словників, а також винесенню взаємозв’язків у окремі таблиці, модель легко підтримується й масштабується.
       З погляду нормалізації БД відповідає вимогам 1NF, 2NF та 3NF. У 1NF усі значення є атомарними, кожне поле містить лише одиничну інформацію, а таблиці не мають повторюваних груп. Вимоги 2NF виконані завдяки тому, що всі атрибути повністю залежать від первинного ключа відповідної таблиці, а проміжні структури винесені у окремі словники. Стосовно 3NF забезпечена відсутністю транзитивних залежностей: неключові атрибути залежать лише від первинних ключів, а всі дублюючі або похідні дані знаходяться у окремих сутностях. Така структура гарантує цілісність та логічну коректність даних у системі.
       Для роботи з базою даних використовується ORM EntityFramework, для обгортки його методів та дотримання принципів чистої архітектури буде використовуватися патерн репозиторія, репозиторій буде створюватися для кожної сутності системи, і містити у собі запити які потрібно виконати до бази даних для кожної конкретної сутності.
       
       5. Специфікація API розробленої системи.
5.1 Users
Опис
     Users представляє всіх користувачів системи CareLink - літніх користувачів, членів родини, медичних працівників та адміністраторів. Ця сутність містить базову інформацію про користувача (ім’я, прізвище, контактні дані, роль) і використовується для аутентифікації, авторизації та персоналізації функціоналу. Через REST API можна створювати, читати, оновлювати та видаляти користувачів, а також змінювати пароль.
     1. Отримати користувача за ID
GET /api/users/{id}
RequestBody: -
Return:
{
    "id": 1,
    "firstName": "Ivan",
    "lastName": "Ivanov",
    "email": "ivan@example.com",
    "phoneNumber": "+380123456789",
    "dateOfBirth": "1945-06-12",
    "address": "Kyiv, Ukraine",
    "roleId": 2
}
     2. Реєстрація нового користувача
POST /api/auth/register 
RequestBody:
{
    "firstName": "Ivan",
    "lastName": "Ivanov",
    "email": "ivan@example.com",
    "phoneNumber": "+380123456789",
    "dateOfBirth": "1945-06-12",
    "address": "Kyiv, Ukraine",
    "roleId": 2,
    "password": "StrongPassword123"
}
     
     3. Вхід користувача в систему 
POST /api/auth/login
RequestBody:
{
    "email": "ivan@example.com",
    "password": "StrongPassword123"
}
     Return:
{
	    "token": "tokentokentokenttoken",
	    "userId": "1"
}
     
     4. Оновити дані користувача
PUT /api/users/{id}
RequestBody:
{
    "firstName": "Ivan",
    "lastName": "Ivanov",
    "email": "ivan_new@example.com",
    "phoneNumber": "+380987654321",
    "dateOfBirth": "1945-06-12",
    "address": "Kyiv, Ukraine",
    "roleId": 2
}
     5. Видалити користувача
DELETE /api/users/{id}
RequestBody: -
Return:
      { "message": "User deleted successfully" }
     
     6. Змінити пароль користувача
POST /api/users/{id}/change-password
RequestBody:
{
    "oldPassword": "OldPassword123",
    "newPassword": "NewStrongPassword456"
}
     Return:
      { "message": "Password updated successfully" }
     
     5.2 Messages
     Опис:
     Messages представляє систему обміну повідомленнями між користувачами CareLink - літніми користувачами, членами родини та медичними працівниками. Кожне повідомлення містить текст, дату відправки, ідентифікатори відправника та отримувача. Через REST API можна створювати, отримувати, редагувати та видаляти повідомлення, а також переглядати історію переписки.
1. Отримати всі повідомлення користувача
GET /api/ message/user/{userId}/ 
RequestBody: -
Return:
[
    {
        "id": 1,
        "content": "Hello, how are you?",
        "sentAt": "2025-12-08T14:30:00Z",
        "senderId": 2,
        "receiverId": 1
    },
    {
        "id": 2,
        "content": "I’m fine, thank you!",
        "sentAt": "2025-12-08T14:32:00Z",
        "senderId": 1,
        "receiverId": 2
    }
]
2. Створити нове повідомлення
POST /api/messages
RequestBody:
{
    "content": "Hello, how are you?",
    "senderId": 2,
    "receiverId": 1
}
     Return:
{
    "id": 1,
    "content": "Hello, how are you?",
    "sentAt": "2025-12-08T14:30:00Z",
    "senderId": 2,
    "receiverId": 1
}

3. Оновити повідомлення
PUT /api/messages/{id}
RequestBody:
{ 
    "content": "Updated message text" 
}

4. Видалити повідомлення
DELETE /api/messages/{id}
RequestBody: -
Return:
{ 
    "message": "Message deleted successfully" 
}

5.3 Relatives
Опис
     Relatives представляє зв’язок між користувачем (літнім користувачем) та його родичем або опікуном. Ця сутність дозволяє родичам переглядати медичні дані, отримувати сповіщення та взаємодіяти з користувачем через систему. Через REST API можна створювати, отримувати та видаляти такі зв’язки.
1. Додати родича до користувача
POST /api/ relatives /{guardianUserId} 
RequestBody:
{ 
    "relativeUserId": 5, "relationTypeId": 2 
}
Пояснення:
• guardianUserId - це ID користувача, якого опікується родич.
• relativeUserId - ID користувача, який є родичем.
• relationTypeId - тип зв’язку.

Return:
{
    "id": 1,
    "guardianUserId": 1,
    "relativeUserId": 5,
    "relationTypeId": 2,
    "addedAt": "2025-12-08T15:00:00Z"
}

2. Отримати всіх родичів користувача
GET /api/ relative/{guardianUserId}/ 
RequestBody: -
Return:
[
    {
        "id": 1,
        "guardianUserId": 1,
        "guardianFullName": "string",
        "relativeFullName": "string",
        "relativeUserId": 6,
        "relationType": "string",
        "addedAt": "2025-12-08T15:05:00Z"
    },
    {
        "id": 2,
        "guardianUserId": 1,
        "guardianFullName": "string",
        "relativeFullName": "string",
        "relativeUserId": 6,
        "relationType": "string",
        "addedAt": "2025-12-08T15:05:00Z"
    }
]

3. Видалити родича
DELETE /api/relative/{relativeId}
RequestBody: -
Return:
{
    "message": "Relative removed successfully"
}
	
	5.4 CognitiveExercises
	Опис:
	CognitiveExercises представляє набір когнітивних вправ для літніх користувачів. Кожна вправа має назву, опис, рівень складності та тип. Через REST API можна створювати, отримувати, оновлювати та видаляти вправи, а також прив’язувати їх до конкретного користувача.
1. Створити когнітивну вправу
POST /api/cognitive-exercise
RequestBody:
{
    "title": "Memory Puzzle",
    "description": "Match pairs of cards.",
    "difficultyId": 2,
    "typeId": 1,
    "userId": 5
}
Return:
{
     "message": "Exercise was created"
}	
2. Отримати вправи
GET /api/cognitive-exercise
RequestBody: -
Return:
[
 {
    "id": 1,
    "title": "Memory Puzzle",
    "description": "Match pairs of cards.",
    "difficultyId": "easy",
    "typeId": "education",
    "userId": 5
}
]
3. Оновити вправу
PUT /api/cognitive-exercise/{id}
RequestBody:
{
    "title": "Memory Puzzle – Updated",
    "description": "Updated logic-based matching task.",
    "difficultyId": 2,
    "typeId": 1,
}
Return:
{
     "message": "Exercise was updated"
}	

 4. Видалити вправу
 DELETE /api/cognitive-exercises/{id}
 Return:
{ 
     "message": "Exercise deleted successfully." 
}
5. Створити результат проходження вправи
POST /api/cognitive-exercise/{exerciseId}/result
RequestBody:
{
    "userId": 3,
    "score": 88,
    "exerciseId": 1,
    "completedAt": "2025-01-12T10:43:00"
}
Return:
{ 
     "message": "Result was saved" 
}

6. Отримати всі результати користувача
GET /api/cognitive-exercises/results/user/{userId}
Return:
[
    {
        "id": 10,
        "exerciseId": 1,
        "score": 88,
        "completedAt": "2025-01-12T10:43:00"
    },
    {
        "id": 12,
        "exerciseId": 2,
        "score": 75,
        "completedAt": "2025-01-19T11:22:00"
    }
]
5.5 IoT Devices
   IotDevices - це реальні фізичні IoT-пристрої, закріплені за користувачами системи CareLink. Кожен пристрій має серійний номер, тип та власника. REST API дозволяє реєструвати нові пристрої, отримувати інформацію про встановлені пристрої, змінювати їх дані та видаляти.

1. Створити новий IoT-пристрій
POST /api/iot-device
RequestBody:
{
    "serialNumber": "HRM-2025-9931",
    "deviceTypeId": 2
}
Return:
{
    "id": 5,
    "message": "Device created successfully"
}
2. Отримати всі IoT-пристрої користувача
GET /api/iot/devices/user/{userId}
RequestBody: –
Return:

[
  {
    "id": 5,
    "serialNumber": "HRM-2025-9931",
    "userId": 12,
    "deviceType": "string"
  },
  {
    "id": 7,
    "serialNumber": "TEMP-8840-553",
    "userId": 12,
    "deviceType": "string"
  }
]
3. Оновити інформацію про пристрій
PUT /api/iot-devices/{id}
RequestBody:
{
    "serialNumber": "HRM-2025-9931-NEW",
    "deviceTypeId": 2
}
Return:
{ 
    "message": "Device updated successfully" 
}
5.6 IoT Device Types
Опис
     DeviceTypes - довідник типів IoT-пристроїв. Тип визначає функціональність пристрою. Адміністратор або система може додавати нові типи при розширенні функціоналу.
     Отримати список типів пристроїв
     GET /api/iot/device-types
     Return:
     [
         { "id": 1, "name": "Heart Rate Monitor" },
         { "id": 2, "name": "Activity Tracker" },
         { "id": 3, "name": "Temperature Sensor" }
     ]
     2. Створити тип пристрою
     POST /api/iot/device-types
     RequestBody:
{
    "name": "Blood Pressure Monitor"
}
     Return:
{
    "id": 4,
    "message": "Device type created successfully"
}
     3. Видалити тип пристрою
     DELETE /api/iot/device-types/{id}
     Return:
{ 
    "message": "Device type deleted successfully" 
}
5.7 IoT Readings
Опис:
     IotReadings - це показники, отримані від IoT-пристроїв: пульс, активність, температура, дата вимірювання. Дані використовуються для моніторингу стану користувача в реальному часі, формування історії та тригерів.
     Додати нове показання IoT-пристрою
     POST /api/iot-readings
     RequestBody:
{
    "readDateTime": "2025-12-08T12:35:00",
    "pulse": 78,
    "activityLevel": 40,
    "temperature": 36,
    "deviceId": 5
}
     Return:
{
    "id": 91,
    "message": "Reading saved successfully"
}
     2. Отримати всі показники пристрою
     GET /api/iot-readings/{deviceId}
     Return:
[
    {
        "id": 91,
        "readDateTime": "2025-12-08T12:35:00",
        "pulse": 78,
        "activityLevel": 40,
        "temperature": 36
    },
    {
        "id": 92,
        "readDateTime": "2025-12-08T12:40:00",
        "pulse": 81,
        "activityLevel": 20,
        "temperature": 37
    }
]
     3. Отримати останні N показань
     GET /api/iot/readings/device/{deviceId}/latest?count=10
     Return:
[
    {
        "id": 102,
        "readDateTime": "2025-12-08T13:00:00",
        "pulse": 80,
        "activityLevel": 55,
        "temperature": 36
    }
]
     4. Отримати показання за період
     GET /api/iot-readings/{deviceId}/range?from=2025-12-01&to=2025-12-08
     Return:
[
    {
        "id": 80,
        "readDateTime": "2025-12-02T10:00:00",
        "pulse": 72,
        "activityLevel": 30,
        "temperature": 36
    }
]
5.8 CognitiveExerciseTypes
Опис:
     CognitiveExerciseTypes - це довідкова сутність, що визначає категорії когнітивних вправ. Вона використовується при створенні вправ, а також у фільтрації та структуруванні завдань для користувачів. Дані зазвичай попередньо визначені, але можуть редагуватися адміністратором.

Отримати список усіх типів вправ
GET /api/cognitive/exercise-types
RequestBody: –
Return:
[
    { "id": 1, "name": "Memory" },
    { "id": 2, "name": "Attention" },
    { "id": 3, "name": "Logic" }
]

2. Отримати тип вправи за ID
GET /api/cognitive/exercise-types/{id}
RequestBody: –
Return:
{
    "id": 1,
    "name": "Memory"
}

3. Створити новий тип 
POST /api/cognitive/exercise-types
RequestBody:
{
    "name": "Orientation"
}
Return:
{
    "id": 4,
    "name": "Orientation"
}

4. Оновити тип
PUT /api/cognitive/exercise-types/{id}
RequestBody:
{
    "name": "Short-term Memory"
}
Return:
{
    "id": 1,
    "name": "Short-term Memory"
}

5. Видалити тип
DELETE /api/cognitive/exercise-types/{id}
RequestBody: –
Return:
      { "message": "Exercise type deleted successfully" }

6. Підготовка до запуску пректу
     Створеня бази даних іде через виконання міграції засобами ORM. Для цього пртрібно скопіювати проект з git репозиторію, відновити залежності командою dotnet restore, запонити файли appsettings.json, та виконати команди нижче.
dotnet ef migrations add InitialMigration --project .\CareLink.Persistence\
dotnet ef database update --project .\CareLink.Persistence\ --startup-project .\CareLink.Api\
     Перед виконанням команд потрібно перейти у дерикторію завантаженого проекту.


4 ВИСНОВКИ
     У межах роботи було опановано повний цикл розробки серверної частини програмної системи, включно з проєктуванням архітектури, моделюванням структури даних та створенням ключових елементів технічної документації. Створені UML-діаграми прецедентів, ER-діаграма та діаграма структури БД забезпечили формальне визначення функціональних вимог, моделі предметної області та взаємозв’язків між сутностями системи. На їхній основі було розроблено логічну та фізичну структуру БД з урахуванням принципів нормалізації.
     На базі спроєктованої моделі даних реалізовано CRUD-функціональність для основних сутностей, описано та задокументовано REST API з визначенням методів, маршрутів, форматів запитів і відповідей. Програмна реалізація API та модулів доступу до БД була протестована для перевірки коректності взаємодії між компонентами системи. 



5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. ASP WEB-API. URL: https://learn.microsoft.com/en-us/aspnet/web-api/.
2. Entity Framework documentation hub. URL: https://learn.microsoft.com/en-us/ef/


ДОДАТОК А
Відеозапис
https://youtu.be/bdJCrr_TMdA
Хронологічний опис відеозапису:
00:00 – Вступ.
02:15 – Структура проекту.
03:27 – Демонтрація роботи API.
11:20 – Кінець.



ДОДАТОК Б


Рисунок Б.1 – Діаграма прецедентів. 


















Рисунок Б.2 – ER діаграма.


Рисунок Б.3 – БД діаграма.
2



